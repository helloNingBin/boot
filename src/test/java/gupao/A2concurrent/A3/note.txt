1.CPU、内存、IO设备，这三者的处理速度差距是非常大的。
   CPU去内存中获取需要处理的数据，这时CPU是要等待数据返回的，这时CPU处于阻塞状态，这对于CPU宝贵的资源是非常浪费的。
   这时在操作系统层面作出了优化，CPU时间片，让CPU最大效率的运行（多线程）。

   同时也增加了高速缓存
2.缓存行(cache line)是CPU与内存交互的最小单位，一次会读取64个字节（应该是根据硬件决定或系统决定的吧）
3.伪共享问题
     X、Y、Z三个变量都在同一个缓存行里
     由于缓存行是CPU与内存交互的最小单位，线程A只需要用到变量A，会去加载缓存行所有的数据X、Y、Z，同理线程B也一样。
     这时线程A去修改X变量，线程B去修改Y变量，即使不是修改同一变量，那么也会出现缓存行的竞争问题。
     当线程A获取缓存行的修改权限时，会使线程B的缓存行失败，线程B只能再去内存中重新读取缓存行。同理当B获取到缓存行修改权限时，线程A
        也只能去重新读取数据，反复如此，会大大影响性能。
     解决办法是：用填充方法，当线程A只能到X变量时，那就是只读取A的数据，数据行不满64位，即填充满64位。其它线程也一样。
4.总线程锁
   valitile关键词修饰的变量，其实就是给总线锁加上lock（lock是一个汇编指令）
   https://blog.csdn.net/qq_35642036/article/details/82801708